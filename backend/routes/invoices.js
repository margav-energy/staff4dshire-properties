const express = require('express');
const router = express.Router();
const pool = require('../db');
const { v4: uuidv4 } = require('uuid');

// GET all invoices
router.get('/', async (req, res) => {
  try {
    // Check if table exists
    const tableExists = await pool.query(`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = 'invoices'
      )
    `);
    
    if (!tableExists.rows[0].exists) {
      console.log('⚠️  invoices table does not exist yet. Returning empty array.');
      return res.json([]);
    }
    
    // Get userId from query param for company filtering
    const userId = req.query.userId;
    
    let query = `
      SELECT i.*, 
             p.name as project_name,
             p.type as project_type,
             u.first_name || ' ' || u.last_name as staff_name
      FROM invoices i
      JOIN projects p ON i.project_id = p.id
      JOIN users u ON i.staff_id = u.id
    `;
    let params = [];
    let paramIndex = 1;
    
    // Add company filtering if userId is provided
    if (userId) {
      // Check which columns exist in users table
      const columnCheck = await pool.query(`
        SELECT column_name 
        FROM information_schema.columns 
        WHERE table_name = 'users' AND column_name IN ('is_superadmin', 'company_id')
      `);
      const existingColumns = columnCheck.rows.map(row => row.column_name);
      const hasIsSuperadmin = existingColumns.includes('is_superadmin');
      const hasCompanyId = existingColumns.includes('company_id');
      
      // Build select query based on available columns
      let selectColumns = ['role'];
      if (hasCompanyId) {
        selectColumns.push('company_id');
      }
      if (hasIsSuperadmin) {
        selectColumns.push('is_superadmin');
      }
      
      // Get user's company_id and superadmin status
      const userResult = await pool.query(
        `SELECT ${selectColumns.join(', ')} FROM users WHERE id = $1`,
        [userId]
      );
      
      if (userResult.rows.length > 0) {
        const user = userResult.rows[0];
        const isSuperadmin = (hasIsSuperadmin && user.is_superadmin) || user.role === 'superadmin';
        const companyId = hasCompanyId ? user.company_id : null;
        
        // Check if projects table has company_id column
        const projectColumnCheck = await pool.query(`
          SELECT column_name 
          FROM information_schema.columns 
          WHERE table_name = 'projects' AND column_name = 'company_id'
        `);
        const projectsHasCompanyId = projectColumnCheck.rows.length > 0;
        
        // Filter by company_id if not superadmin and company_id exists
        if (!isSuperadmin && companyId && projectsHasCompanyId) {
          query += ` WHERE p.company_id = $${paramIndex}`;
          params.push(companyId);
          paramIndex++;
        }
      }
    }
    
    query += ` ORDER BY i.created_at DESC`;
    
    const result = await pool.query(query, params);
    res.json(result.rows);
  } catch (error) {
    console.error('Error fetching invoices:', error);
    res.status(500).json({ error: 'Failed to fetch invoices', message: error.message });
  }
});

// GET invoice by ID
router.get('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const result = await pool.query(
      `SELECT i.*, 
              p.name as project_name,
              p.type as project_type,
              u.first_name || ' ' || u.last_name as staff_name
       FROM invoices i
       JOIN projects p ON i.project_id = p.id
       JOIN users u ON i.staff_id = u.id
       WHERE i.id = $1`,
      [id]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Invoice not found' });
    }
    
    res.json(result.rows[0]);
  } catch (error) {
    console.error('Error fetching invoice:', error);
    res.status(500).json({ error: 'Failed to fetch invoice' });
  }
});

// POST create new invoice
router.post('/', async (req, res) => {
  try {
    const {
      project_id,
      staff_id,
      time_entry_id,
      job_completion_id,
      supervisor_id,
      amount,
      hours_worked,
      hourly_rate,
      description,
      status = 'pending',
      due_date
    } = req.body;

    if (!project_id || !staff_id || !amount) {
      return res.status(400).json({ error: 'Missing required fields: project_id, staff_id, amount' });
    }

    const id = uuidv4();
    // Invoice number will be auto-generated by trigger if not provided
    const result = await pool.query(
      `INSERT INTO invoices (
        id, project_id, staff_id, time_entry_id, job_completion_id,
        supervisor_id, amount, hours_worked, hourly_rate, description,
        status, due_date
      )
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
       RETURNING *`,
      [
        id, project_id, staff_id, time_entry_id || null, job_completion_id || null,
        supervisor_id || null, amount, hours_worked || null, hourly_rate || null,
        description || null, status, due_date || null
      ]
    );

    res.status(201).json(result.rows[0]);
  } catch (error) {
    console.error('Error creating invoice:', error);
    res.status(500).json({ error: 'Failed to create invoice', details: error.message });
  }
});

// PUT mark invoice as paid
router.put('/:id/pay', async (req, res) => {
  try {
    const { id } = req.params;
    const { paid_by } = req.body;

    if (!paid_by) {
      return res.status(400).json({ error: 'paid_by is required' });
    }

    const result = await pool.query(
      `UPDATE invoices 
       SET is_paid = TRUE,
           status = 'paid',
           paid_at = CURRENT_TIMESTAMP,
           paid_by = $1,
           updated_at = CURRENT_TIMESTAMP
       WHERE id = $2
       RETURNING *`,
      [paid_by, id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Invoice not found' });
    }

    res.json(result.rows[0]);
  } catch (error) {
    console.error('Error marking invoice as paid:', error);
    res.status(500).json({ error: 'Failed to mark invoice as paid', details: error.message });
  }
});

// PUT update invoice
router.put('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const updateData = req.body;

    let updateFields = [];
    let values = [];
    let paramIndex = 1;

    const allowedFields = [
      'status', 'amount', 'hours_worked', 'hourly_rate', 'description',
      'due_date', 'is_paid', 'paid_at', 'paid_by'
    ];

    for (const field of allowedFields) {
      if (updateData[field] !== undefined) {
        updateFields.push(`${field} = $${paramIndex++}`);
        values.push(updateData[field]);
      }
    }

    if (updateFields.length === 0) {
      return res.status(400).json({ error: 'No fields to update' });
    }

    updateFields.push(`updated_at = CURRENT_TIMESTAMP`);
    values.push(id);

    const result = await pool.query(
      `UPDATE invoices SET ${updateFields.join(', ')} WHERE id = $${paramIndex} RETURNING *`,
      values
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Invoice not found' });
    }

    res.json(result.rows[0]);
  } catch (error) {
    console.error('Error updating invoice:', error);
    res.status(500).json({ error: 'Failed to update invoice', details: error.message });
  }
});

module.exports = router;

